# -*- coding: utf-8 -*-
"""Phone reorientation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vVJ-ArQLyRnQ3Kj_-3qhKbbdAX9zskp-

# 1- Introduction

---




In this notebook, I am embarking on a fascinating journey utilizing recorded data from my personal iOS smartphone to assess the algorithm's capability to reorient the phone. To ensure the highest quality dataset, I carefully positioned my phone in the cup holder, a strategic choice aimed at minimizing extraneous noise during recording. Additionally, this positioning method guaranteed that the phone maintained a consistent angle with the car, which is pivotal for our subsequent analysis.

To enrich the dataset and enable a comprehensive evaluation, I will harness a combination of sensors available on iOS devices. Specifically, I will tap into the power of the Global Positioning System (GPS), gyroscope, accelerometer, and magnetometer. Each of these sensors offers unique insights into the phone's orientation and movement, enabling us to build a robust algorithm for reorientation.

GPS data will serve as a fundamental component, providing geographical coordinates and potentially aiding in validating the reorientation process by cross-referencing with real-world positioning.

The gyroscope will play a crucial role in capturing angular velocity, while the accelerometer will provide information about linear acceleration. These two sensors are indispensable for understanding how the phone moves and rotates within the car's environment.

Furthermore, the magnetometer will allow us to tap into the Earth's magnetic field, providing valuable information for determining the phone's orientation relative to geographic north. This data will be pivotal for calculating azimuth and heading, which will serve as the key parameters for rotating the phone accurately.

By leveraging this multi-sensor approach, my overarching goal is to develop an algorithm that can effectively utilize azimuth and heading data to dynamically reorient the phone in real-time. This reorientation capability has the potential to enhance a wide range of applications, from navigation systems to augmented reality experiences.

Throughout this notebook, I will meticulously analyze and process the sensor data, develop and fine-tune the algorithm, and finally, evaluate its performance in achieving the desired phone reorientation. This project promises to unlock exciting possibilities for improving the user experience in mobile applications and beyond.

*   Frequency of collected sensors are 10 Hz and for the GNSS is 1 Hz like intact dataset.

![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAYcAAAAxCAIAAAC+mPL1AAAAAXNSR0IArs4c6QAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAABh6ADAAQAAAABAAAAMQAAAACJIc1DAAAUwklEQVR4Ae2ddZBdxRLGCQTn4W7B3SVAIUGCBHcnuGvhrkXQwqqgoIDC3d3dKdwthRbu7u/9kub1DvPNOTn37N3dezdz/ziZM9Pd090jp2d25kufV155ZZT8yx7IHsgeaBkP9EWTueeeu2X0qaPIq6++mk2o47im8vSCVmiqP3pGWC9oBUwYtWecl2vNHsgeyB4o8ECelQock7OzB7IHesgDeVbqIcfnarMHsgcKPND8Wem9997766+/Cqprs+znnntuttlm+/vvv5uid9Izyczq1XWS3SpyIc21t6IVXntF+iSZC2mKCS4tWVeU2RBxxJtfkx5o/qw0//zzv/XWW8nK2i5zlllmOf7440cdtTleSnommVndUZ1kt4pcSHPtrWiF116RPknmQppigktL1hVlNkQc8ebXpAf+Nd5uv/32lVdeecCAAeeffz7U22233X333Wdsm2666UsvvRQRfPDBB9tuuy3jdokllthjjz1+//337bff/qefftpxxx2POeaYZH1dnRlpeOyxx5544olU+uCDD2611VYovMMOOxx99NGLLrooSqIqRRELNNtss82uu+66+OKLf/vtt5dffjk0ZinSFltssQMPPPCRRx5ZdtllV1999aFDh5pFKqSKZ9xdJoTnzz//vNNOOy2yyCJbbrklr2h77733Wqk1QVjq7ObtpA4lOpvYUEhte02UPdvdhNAhWBR5NepREXHoh5yu7wHOK/13+O+NN94Yf/zx77nnnltvvXXcccd96qmn9txzzw022IDC559/nhwlePnll6l48ODB999//9RTT33ppZe+8MIL44wzDgnCJRPbDc8SE4jnxxxzzCeffJJP6MUXX2wKM+k89thj88wzD/NLkVGbbLLJDTfcAP1EE02ECca49dZb00fHHnvsfv36kVhzzTWZKSgtEjJCz7i73ISzzz57ySWXZBK84oorkLz33nuvvfbaJDBkvPHGi0qdHW8X6VCkMzLtFwqpbS+ieoEJ6hD1atSjQu/949Ae/cdboUe16FTlmDDsvJL97rjjjqmmmoosXqeccsonnnhis802I2768ccfr7rqqnXWWUcJVlhhBSayCy+8sE+fPiuuuCKBAyx9+/ZdaKGFZp111v8L7r5/VUMm1t122424hqG+xRZbYB0Kn3feeShMrIRdU0wxRWQ1RjEFX3DBBUxn5g0zAEZCSBixji/koEGDvvvuu9NPP51SrbeiZwj+zV2+dTXDDDMwNTAhMpsgmfiOuOmbb75B1XXXXTcqdXa8fdppp6khJTp7q4RCatvbv39/Fxgp2XYmhA5Rr0Y9Cqt7sMO7z3tZomMFx+zDOLTfPvvsw6hjmTPddNPdfPPNV1999eabb64E+GK00UZjoJKAscc3uZMaTjvttL/++uvkk09uLecKjzXWWEzpSZYxxhgDc6KWdkZKSVNKwmaTpBCnb8gzrKCvu+66W265ZY455vjqq6/mnXdeDohec801zEo0QVQaaliug+oc8ibTrr/yJutyIZGS7WiC25K0NOpRTpwTzfJAx6y0wAILfP755+uvv/7OO++84YYbTjPNNNRB7HPIIYew/zJw4MAkgepBJ/7oo4/8468EXZejGn744YdHHnkk45y5lcUpVRPgMMhRj0y+ispSQ72KQpKesUyv9M0331xmmWXuvPPOP/74gzT5xBqHH374b7/9RvylpS6zog5eUZhwIWFmSbq8LlWy7Uxwh6il2qOcuMRjuaghD3TMSqutthrbt+y/8Ldw9lzY2kAQsxIJdk/4cioBUZIFSlDyhypLr7XWWmussQbLpYb0aAqxasi+DDtErH0OO+ywXXbZhVow5KijjmJpg13sKynLcJuGRX/8PO0Jy7S/ynlmuZByz5i7htc27EGUxA7djDPOSIix8MILk4Pzv/76a57I0VL3drkOqBrp7DWScCFukScoVV6tK5SmSradCe4QtVR7lBOHTsjpTnmArYRwb4rFzmeffUYo4Zn8ZS18jQgoNco///yTFZylGUV86l1CVydKTHD10IFww3Zz0fOLL74ItSoyChqX4AlMc4eEZhYJGaFncFdowg8//ECOq0eaxSa7qpYTlZIZertIhyKdw1rMFjfTE0W8UV29wAT3RolX3S3Q0KOMJWyCUEj3p8NW6P7am1IjJozSO8yo6A7/G1NF+m4jK2mFM888k7ip2zSpXVEvMKG27a3DWNIKraNkuSaY0LGC61TE1SbMc845JxNTmyj7j5pscj/66KPtpXOkbS8wIbIov3apB/owM3VpBVl49kD2QPZAQx7I+EoNuauriHsHLE67o1x1VetmuY14IOMrNeKtTJs9kD3QLR4YufaVusWluZLsgeyBTnkgz0qdcl9mzh7IHmi6B/41K51wwglclF9qqaWuvPJKauJ42CrBjwtlVj1/ElpuueW4smuvnODg2CSEPE866SSOt5TwGkuLPO+66y6OyS299NL89T1SSYuiHLfaPPT6669HEuw14iJTc5KMFTM5DEWrcU9Y6bmwwqUtQA64Bvjaa69BcM4559iVQANCqG1CJCeqmpsABxxwANeVOIyOsVYaWa005Oy7775c+qNrcfM5kslrJIGccjWUvsRXWqQ5rpIWqauNGKPoYNZDuElKJvcKgiG1Cia4WBKRRUlird0kcDkGh1OjvXJhHhgP0slRTNODM7H88svTH8444wz+VG9c9lTXkc9BOU5Zc9MjpCStxJoTsYz41Q843HTTTVwWA/GDPnHKKaegKIZRAXrzl10SoAjYQQOO6nJvnosp9gr8BdVcf/319HWu9YITUsJrLM19ugkNiX377bex4qKLLuImygQTTIDVzq5FmmNWc20FL/GjzYwdDDBOjVtauTTHKOuZwAdgwQUX5FbEpJNO6sp7gq8LN4e44/7QQw9xB4gj15NMMgmqcqVu9NFHZ56qZ4LKiUx45plngFuhIpBwuOcMsIlarTR85Pbbbz/ymZtAR2DsuSEkVEKRGsal9CW+0iLNcWWSRZGrnfjTTz/FFkA4+NHNyKd7cPnJftymPvnkk51YLVLiZO0mgZmRYejnby+55BIiDIpoCB3FBBDzzTffjTfeSAfmhhNXzVwNdZ0VcTd2wgkn5BK+U5JQYs0J6aukh50K8PFAvMBdEz+u6vzc2OAqmb8y/OhqXLunizPjkm+d2wwDDwh6J454Pb+5CTehIbFDhgxZddVVjYXxA4SAs2uR5oRWOyOJQw891OZl0sqlOcZbzwQOqRO3gsqisxLDmz7EjOC6cVUCHAJ7ZRRxG76eCSqnyAQAuRgnzNFFVsPoNK7nww8/zOWYX375xXNIqIQiNYxL6Ut8pUWag9hTTz0VxBgtUlc7MbPSxBNPbCpFz8cffxzMH6YSzy+xyIm1dmcvmpWMIByJhBfgHDDlOW+YUNdRyjcMdA2Q1HxWMm8oseaEwqukGQsdKzhwfJhxuHvF9AlzUZRFTMTHmfuWGBZG2oRaKHrttddyv7eIt6Xy33///dlnn91UmnnmmT/55BNXT4s0x4hZPR1xxBFRHF5DjrM0lGD0gtCSZDHcH6DjWJ/utddetCxAUbQ3HxJ+tB1fEWNs1IQiOaoG0QGYE9ywL/IeLE5Dmk86/Z6udfDBB3PJJhSoEsrVUPoSX2mR5qAMcQ1zqBapq52YK4TcBme1QdBKfBRaxHKEJQhzlmeWWOTEWruzV08QlnKcGIywJIu6DjIWg/RzPn7OYt5QYs1xluqJDnwlLoXidJAbuVjL1HPZZZclpYDotvHGG3PHFUeTZtVqZHfffTdzMJMaV2GTjK2WyTUugj7TilHK1TbXUIs0x4j/M/xHlM4r8JVAtRGe0BeZoJkRlEtzvNLmJthloI0Y4YS0oGISN7GqYmDwxcNY1kfE7fVMIK5Myon0BzmAmNEQqYqsDmlgJ3b78ssviSCYnljNPfDAAwx48vnOqwRVg+9iCX2kXo1XVsFJLnU1awsjplOxfMbhhLSMCzDL2G5DyLvvvsvq6cUXXwwFqkVWmiQOGRtN42fv+cZb7jrCFNqFxQSgY16XGciq00XZINKWcpbqiY5ZCR7mQmYl1px0WaZnenAk6OOPPwYzlyUDV/CpnpCKT4HRsAAkvARygK8fYV7E2IKvGOvxEZG2AzChqhbxHUsSg0Mw2WSTmXXMRMQdDEWgLUAjAFbpoIMOiriK5DTdP4AiYBFLVCSzF85qny2/p59+mpURYQg7Dg7L16gJRXJCE/Anu7zEaOuttx756k8yIxpyNhr+YxeWDySDloqwgnx2wVSCqsEuYQk9crrop672ijy04W8OQKE+++yzNisBFkgANddcczklCbXISpPEIaOlMZ/PIftK9DFymHrMG0o500wz8T1g/HpAWu46tsP51rLVDYoL/Xn//fc31Gkka7s0p4f7jgbzJX2XiYYOwbjyLYlwRUrYxoqA2Ycf39vpp5/+3HPPDbcn2FcyRFdbQIa8ltMVTzehIeHYi08BSEB/kENAtqOdWIthuBZpTmh1WG+4r6RcmmO89Uww3nBfyU0gauDbRYOSw5AAbZq/zrB2g4U/SrC7j/71TFA5kQkMDJBwdt99d8vnqVYrDcsKhgrEPBktwHs6e1JCkRrGpTVafuirUD5pLYpy+MMIyxOVo66GxojfeecdogxeaV9iQODeSeN2Imz2v02UN1nSoojYWCLFLJMnG9j8DYqByR4TiKm+v0lROBK///57PqXEzkR5pPmUmpImR11H0xCL8GPnC7G8QmkGKrHmmNjqT3zVsdt91llnEYwR6vOjSpcCxJKbR/+GzIuICFZaaSULlwwbhK8xgwFEV6MJeZ2r6Yl6Q5o/Z7Cwx2TW9gTPtCWhMsqzo6lFmkMf4hsOPU9+/KXD7OL2L0fmLa1cmmOU9Uzg28ACjQ8dXy06OsGam4BYVpQU8e0ibGFfiWCbjyfdkSmYHgZBPRNUTmQCnce+z3y6+aGVWq00t912Gw1BeI7OaO5YMSZcJRSpUUSvvjJKnlqkOZAxLpjQk0WRq50YetqF0I+nDyJCD/vvvEwBb7KkRRFxsnaTw5NYDAhTpj+mdeJODywoikYi2+dcD2KNT9dlbURPcCHqai9iPQ7QqL2aN5RYc5y9YoKxMOx2rl9fQiITChEEkacHfjiCV7oXORBghhdRDYOZnDA/TIe8ztX0RGcukdFyWOehLOYw0ZiGURGZmlPFFuXSnM6YEOkQmsDHkIbzlT+dj7+xhjusEW/Ra6RwUs4ITYiEaF3MRHzbUC/sYyFZJCGpRgl9WFQjjesUN9nlRK52YoYDgSEfAx9TNuEyIzivN5lapMTOVZRgCNPiLHdCguRIRGdcnTQqcrWJYrwjxwaIG0iREmtOqEx5mo70r1mpnLplS0c4HlpWc1csm+CuyImR3AOMhY6YaCT3RTY/eyB7oEU8kPGVWqQhshrZA9kD/3hg2B6K7yu1qVfy8qcVGq4XtEIruDHrkFdwuQ9kD2QPtJwH8r5SyzVJVih7YCT3QJ6VRvIOkM3PHmg5D3TMShz85WoC4C9cbeOQOwclTNkITYkzDkkYF4g5JBrCMyGQA1qOJlOEQNSDLuEIbIRA5MpwYGzAgAGcGjW8BA6SROg/Fa3jSlcI4YQcxR7ySmskOOqC2zO+krou8jwEJb7SIs2xKpItGPUWVyZJrIq55AiMSXtdUqCxFw3M9sZXsvsHBpPEEVvuKNhZzAhNqQgwgZPmETyTCVQEoopHPKuT1TsYjfwiWBzO1HNUjNPG3Dfm8DSXA8iJ0H+KrCvHV1JcITOzngmc0Mv4Sg4XFXYYRfkp8ZUWaY4L1xbU3lJCrIo5MRcDIzAm7XVau7MXDcz2xleyYWYwSYxALuNhsKIpFRmv8EyhQPddVyTqDekkLI6pxwVjLmqgP3dZOenuV5YodfSfIuvCe3AlWDMRrlA9Ezhom/GVaBSDiwq7lnq+xFdapDkI5+oMt5G8Fm/BZG8pIlbFXCCzEufa/TVMeK/zTK/dc4oGphGE9+DaCV/Jw06GIpALhj1UhKbkxJ4ogmdifVGCQOTs3Z/gUiU3hkIEItcBkFYuIYPW2r9/f4LqQYMGUUTgreg/5daVYM2EuEJeb6MJLjFkfCWW0gS2DhdlPlTPl/hKizQHsYYo5G3kLZjsLUXEqpgL5G6QgjElex0sXruzV08QgrUNvpJZxcYQF4jBWwB5i5wiNCV1QRE8E/cS+RkCkXL1YA7r8AiBiC0k04c9BRZuXI7jmzl06FC+QtxjIjjCM47+Y5ShdVXwlYwrwhWyzOY+1bqMr9RJD4f4SmELJntLETEIAX4tkcnUd2/RjahcwZiiXmfgJGHtNYxCputg7Gy/lEBT9TC+EioCJkmUxNgjnURT4ko3k3oSxgW3hvBMduU1hO+p4cGuYymBxQEXgSUVN7CpHVCE4447DrSpCP3H4O5C6wjaCZ3K8ZUQqLhCXWGjWlcE39OoCUVyQisiG+kYEc5U0g+Rh6nIBiE3SFWCqkHPLKEP1etkOrIu2Vu8iohYDXFKD9BCMKbIJ4MHD44EOnvJwHQaS7QTvpJulCTRlFimJmFcmG4jeCYV6Gvg5ibqbcooLI4j3YDWxvKNW9Hseg4cOBB4UIJePlCozZPZFvSfIuvCfSXFmlFcIXNFPROMN0TbcRPUOv58w2IHloyvZH6LnqEb1bHkGKKQtqD2lhJi7RLeZArGpL1Oaw+tSA5MIwj3ldoJXymESTJLkmhKFCVhXBSeiWHAV44wlSc/RyAK/diUdO0hHcHiONINi38amCiXby9/5OJV0X+KrCvHV1JcIfNAPRNYYGZ8JYeLCvsSn5MIPEt95fRapDkQG6KQtqD2lhJiVcx7nYIxaa/T2t0KEsmBaQTtja/E9OHxHh4MXzGPJbTnKIwL9ArP5NK6LtGZG1jsv4QIRBjINGqqEg0RVNuigBy2AMrRf4oMrII10xkTonpDEyLrmEkJADO+UuSxiq8hopCyRL2lnDjqEt5kjCCioQiMqdFepwMTbZln6cx09VBzugfDOeMrhT5pWrqJQ7ppOjUoKJvQoMMyea/1AGOh42x3r7UyG5Y9kD3QVh7I+Ept1VxZ2eyBkcAD/wOhoHwsqlXwhAAAAABJRU5ErkJggg==)![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZkAAAAxCAIAAACH/0OuAAAAAXNSR0IArs4c6QAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAABmaADAAQAAAABAAAAMQAAAADfVKyoAAAU1ElEQVR4Ae2ddbBktRLG38LiPNzd3WWhCllkkcX9oYu7Fu4OixVWBQUFFO7u7k7hblto4e7+3m9p6Bvy5WTnjuybmc38MTcn6XS6v5PkdDIn3+3z4osv/qt8CgIFgYJAhyPQF/vnnHPOjvbipZde6nQXmoV/N0HRTb406/4WPVUI0FtGqior+QWBgkBBoIMQKHNZB92sYmpBoCBQiUCZyyqhKQUFgYJAByHQ/Lns7bff/v333zsIgoypTz/99CyzzPLHH39kZGovSiLjmc1tq3arTNLN6G3FUN6VFF9CWEg7MlF+8rJXwkkNI2Zm8+eyeeed9/XXX+8ONGeaaaZjjjlmpJGag1ISGc9sblu9xd/N6G3FUN6VFF9CWEg7MlF+8rJXwkkNI2gm72T89+/PzTffvPzyyy+55JJnn302eVtuueVdd91lhRtssMFzzz0XCbzzzjtbbLHF4MGDF1100Z133vnnn3/eaqutRh555CWWWOLwww//W2vL/2ZcOPLII4899lgsuPfeezfddFMM3nrrrQ877LCFFlpom222+e677yhSpzbffPMddthhkUUWQX7ttddGxjxFW79+/fbZZ58HHnigf//+K6+88ptvvmnuqZJakAnhqrstM8C+HYrvv/9+2223XXDBBQcNGkQRXt95550mY7cyLA3NQCbpS8Z3UxsqKb4YJoqMwht10RDGUElJ5xEY+m6Z9/5XX311nHHGocffdNNNY4011uOPP77rrruuu+66qHjmmWfIUYEXXniBJwCj5Z577pliiikuuuiiZ599dswxxyRBaJZvu4mlGRdY7Iw22miPPfYYkcIFF1xgBjPLPPzww3PNNde+++5b5RQD/tprr0V+/PHHx1SryBx3yy23jDHGGNNOOy2J1VZbbcMNN6S0SskwkQnhqrutEEmH4owzzlhsscXefffdSy+9FIHdd999jTXWIAEgY489dlQamlHlS5Xv3nqopPjC8Ekio/BGXTSE0TWUxDARoOcPfb/MPrfeeuvkk09OFpeTTTbZo48+utFGGxF9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)

## 1-1- Load the Data
"""

#libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import os
import math

import random
from lightgbm import LGBMRegressor
from xgboost import XGBRegressor
from sklearn.model_selection import RandomizedSearchCV
from scipy.stats import uniform
from sklearn.model_selection import train_test_split
import time
from sklearn.metrics import r2_score
from sklearn.metrics import mean_absolute_error
from sklearn.metrics import mean_squared_error
from sklearn.metrics import max_error
from sklearn.feature_selection import SelectFromModel

#load the data
from google.colab import drive
drive.mount('/content/drive')

acc=pd.read_csv(r'/content/drive/MyDrive/Accelerometer.csv')
gyro=pd.read_csv(r'/content/drive/MyDrive/Gyroscope.csv')
gnss=pd.read_csv(r'/content/drive/MyDrive/Location.csv')
mag=pd.read_csv(r'/content/drive/MyDrive/Magnetometer.csv')

acc

gyro

gnss

mag

"""## 1-2- Data Description and visualization

### 1-2-1- Acceleration
"""

acc.info()

#Drawing the plot of
t = np.linspace(0, len(acc)/10.0, len(acc))
plt.title('Acceleration over time')
plt.plot( t, acc['X (m/s^2)'], color ='blue')
plt.plot( t, acc['Y (m/s^2)'], color ='red')
plt.plot( t, acc['Z (m/s^2)'], color ='green')
plt.legend(['x', 'y','z'])

plt.ylabel("$m/s^2$")
plt.xlabel('Time (Sec)')
plt.show()

sns.set(style="darkgrid")

fig, axs = plt.subplots(2, 2, figsize=(10, 8))

sns.histplot(data=acc, x='X (m/s^2)', kde=True, color="skyblue", ax=axs[0, 0])
sns.histplot(data=acc, x='Y (m/s^2)', kde=True, color="olive", ax=axs[0, 1])
sns.histplot(data=acc, x='Z (m/s^2)', kde=True, color="gold", ax=axs[1, 0])
sns.histplot(data=gnss, x='Velocity (m/s)', kde=True, color="olive", ax=axs[1, 1])

plt.show()

t = np.linspace(0, len(acc)/10.0, len(acc))
ax=sns.scatterplot(data=acc, x=t, y='X (m/s^2)')
ax=sns.scatterplot(data=acc, x=t, y='Y (m/s^2)')
ax= sns.scatterplot(data=acc, x=t, y='Z (m/s^2)')

ax.set(xlabel='Time $seconds$', ylabel='Acceleration $m/s^2$')
plt.legend(labels = ['x', 'y', 'z'],loc='upper left', bbox_to_anchor=(1, 1))

from pandas.errors import AccessorRegistrationWarning
from mpl_toolkits import mplot3d
import matplotlib.pyplot as plt
import numpy as np


# Creating random dataset
x = acc['X (m/s^2)']
y = acc['Y (m/s^2)']
z = acc['Z (m/s^2)']

# Creating figure
fig = plt.figure(figsize = (16, 12))
ax = plt.axes(projection ="3d")

# Add x, and y gridlines for the figure

# plot the plane

# Creating the color map for the plot
my_cmap = plt.get_cmap('hsv')

# Creating the 3D plot
sctt = ax.scatter3D(x, y, z,alpha = 0.8,c = (x + y + z),cmap = my_cmap,marker ='^')

plt.title("3D scatter plot in Python")
ax.set_xlabel('X-axis', fontweight ='bold')
ax.set_ylabel('Y-axis', fontweight ='bold')
ax.set_zlabel('Z-axis', fontweight ='bold')
fig.colorbar(sctt, ax = ax, shrink = 0.6, aspect = 5)

# display the plot
plt.show()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn import linear_model
from mpl_toolkits.mplot3d import Axes3D



######################## Prepare model data point for visualization ###############################

x = acc['X (m/s^2)']
y = acc['Y (m/s^2)']
z = acc['Z (m/s^2)']

x_pred = np.linspace(-5, 5, 100)   # range of x
y_pred = np.linspace(-5, 5, 100)  # range of y
xx_pred, yy_pred = np.meshgrid(x_pred, y_pred)
model_viz = np.array([xx_pred.flatten(), yy_pred.flatten()]).T

################################################ Train #############################################
Y=acc['Z (m/s^2)']
X= acc[['X (m/s^2)','Y (m/s^2)']].values.reshape(-1,2)
ols = linear_model.LinearRegression()
model = ols.fit(X, Y)
predicted = model.predict(model_viz)

############################################## Evaluate ############################################

r2 = model.score(X, Y)

############################################## Plot ################################################

plt.style.use('default')

fig = plt.figure(figsize=(12, 4))

ax1 = fig.add_subplot(131, projection='3d')
ax2 = fig.add_subplot(132, projection='3d')
ax3 = fig.add_subplot(133, projection='3d')

axes = [ax1, ax2, ax3]

for ax in axes:
    ax.plot(x, y, z, color='k', zorder=15, linestyle='none', marker='o', alpha=0.5)
    ax.scatter(xx_pred.flatten(), yy_pred.flatten(), predicted, facecolor=(0,0,0,0), s=20, edgecolor='#70b3f0')
    ax.set_xlabel('acceleration X', fontsize=12)
    ax.set_ylabel('acceleration Y', fontsize=12)
    ax.set_zlabel('acceleration Z', fontsize=12)
    ax.locator_params(nbins=4, axis='x')
    ax.locator_params(nbins=5, axis='x')




ax1.view_init(elev=28, azim=120)
ax2.view_init(elev=4, azim=114)
ax3.view_init(elev=60, azim=165)

fig.suptitle('$R^2 = %.2f$' % r2, fontsize=20)

fig.tight_layout()

sns.boxplot(data=acc[['X (m/s^2)','Y (m/s^2)','Z (m/s^2)']],dodge=False).set(
    xlabel='Acceleration x',
    ylabel =' $m/s^2$ '
)

#Correlation of acceleration
plt.figure(figsize=(8,8))
correlations = acc.corr()
heatmap= sns.heatmap(round(correlations,2), cmap='BrBG', annot=True, annot_kws={"size": 10}, vmin=-1, vmax=1)
heatmap.set_title('Correlation heatmap', fontdict={'fontsize':18}, pad= 12)

"""### 1-2-2- GNSS"""

#Drawing the plot of speed
t = np.linspace(0, len(gnss)/10.0, len(gnss))
plt.title('Speed over time')
plt.plot( t, gnss['Velocity (m/s)'], color ='red')

plt.ylabel('$m/s$')
plt.xlabel('Time (Seconds)')
plt.legend(labels = ['speed'],loc='upper left', bbox_to_anchor=(1, 1))

plt.show()

#Drawing the plot of speed
t = np.linspace(0, len(gnss)/10.0, len(gnss))
plt.title('Heading over time')
plt.plot( t, gnss['Direction (°)'], color ='skyblue')

plt.ylabel('$m/s$')
plt.xlabel('Time (Seconds)')
plt.legend(labels = ['Heading'],loc='upper left', bbox_to_anchor=(1, 1))

plt.show()

import plotly.express as px
import pandas as pd


geo=pd.DataFrame()
geo['Lat'] = gnss['Latitude (°)']
geo['Long'] = gnss['Longitude (°)']
geo['speed']=gnss['Velocity (m/s)']

#geo.dropna(axis=0, how='any', thresh=None, subset=None, inplace=True)

#color_scale = [(0, 'orange'), (1,'red')]
#size="car_hours" this two varible could changed for color scale and size of dot points
fig = px.scatter_mapbox(geo,
                        lat="Lat",
                        lon="Long",
                        color_continuous_scale=px.colors.cyclical.IceFire,
                        color="speed",
                        zoom=8,
                        height=800,
                        width=800)

fig.update_layout(mapbox_style="open-street-map")
fig.update_layout(margin={"r":0,"t":0,"l":0,"b":0})
fig.show()

"""### 1-2-3- Magnetometer and Gyro"""

t = np.linspace(0, len(mag)/10.0, len(mag))
plt.title('Magnet over time')
plt.plot( t, mag['X (µT)'], color ='blue')
plt.plot( t, mag['Y (µT)'], color ='red')
plt.plot( t, mag['Z (µT)'], color ='green')
plt.axhline(y = 65, color = 'gold', linestyle = '--')
plt.axhline(y = -65, color = 'gold', linestyle = ':')
plt.legend(['x', 'y','z'])

plt.ylabel(u"\u03bcT/s")
plt.xlabel('Time (Sec)')
plt.show()

t = np.linspace(0, len(gyro)/10.0, len(gyro))
plt.title('Gyro over time')
plt.plot( t, gyro['X (rad/s)'], color ='blue')
plt.plot( t, gyro['Y (rad/s)'], color ='red')
plt.plot( t, gyro['Z (rad/s)'], color ='green')

plt.legend(['x', 'y','z'])

plt.ylabel("rad/s")
plt.xlabel('Time (Sec)')
plt.show()

"""# 2- Data preprocessing

In this section merge the sensor and scaale of up the gnss data to match the rest of the dataset. Also, I would apply Normalization on the dataset.
"""

geo.describe()

geo['heading']= gnss['Direction (°)']
geo['time']=gnss['Time (s)']

#Estimating the delta after merging
geo['delta']=geo['speed'].diff()
geo=geo.fillna(0)

#This graph show when the acceleration are

t = np.linspace(0, len(geo)/1.0, len(geo))

s=geo['delta']
# plot input vs output

upper = 2
lower = -2

supper = np.ma.masked_where(s < upper, s)
slower = np.ma.masked_where(s > lower, s)
smiddle = np.ma.masked_where((s < lower) | (s > upper), s)

fig, ax = plt.subplots()
ax.plot(t, smiddle, t, slower, t, supper)


plt.title('GPS speed deviation')
plt.xlabel('Time (seconds)')
plt.ylabel(u'Δ')
plt.show()

#Correlation of gnss
correlations = geo.corr()
heatmap= sns.heatmap(round(correlations,2), cmap='BrBG', annot=True, annot_kws={"size": 10}, vmin=-1, vmax=1)
heatmap.set_title('Correlation heatmap', fontdict={'fontsize':18}, pad= 12)
plt.grid(False)

dt= pd.DataFrame()
dt['time'] = round(acc['Time (s)'].astype(float),1)
dt['Acc_x'] = round(acc['X (m/s^2)'].astype(float),3)
dt['Acc_y'] = round(acc['Y (m/s^2)'].astype(float),3)
dt['Acc_z'] = round(acc['Z (m/s^2)'].astype(float),3)

dt

dgps= pd.DataFrame()
dgps['time'] = round(geo['time'].astype(float),1)
dgps['speed'] = round(geo['speed'].astype(float),3)
dgps['heading'] = round(geo['heading'].astype(float),3)
dgps['delta'] = round(geo['delta'].astype(float),3)

dgps

df= pd.merge(dt, dgps, on='time',how='outer')
df

from scipy.interpolate import interp1d

df['delta'] = df['delta'].interpolate(method='polynomial',order=2)
df['heading'] = df['heading'].interpolate(method='polynomial',order=2)
df['speed'] = df['speed'].interpolate(method='polynomial',order=2)

df['delta'] = df['delta'].fillna(method='ffill')
df['heading'] = df['heading'].fillna(method='ffill')
df['speed'] = df['speed'].fillna(method='ffill')

df['delta'] = df['delta'].fillna(0)
df['heading'] = df['heading'].fillna(141)
df['speed'] = df['speed'].fillna(0)

df

df.isna().sum()

"""# 3- Method 1: 3D dimenation reorientation

getOrientation: This method computes the orientation angles (azimuth, pitch, and roll) from a given rotation matrix. It takes in two parameters: R (the rotation matrix) and values (an array to store the resulting orientation angles).

The method utilizes trigonometric calculations to extract the orientation angles from the rotation matrix. The resulting angles are in radians and represent the device's azimuth (rotation around the Z-axis), pitch (rotation around the X-axis), and roll (rotation around the Y-axis).

The computed orientation angles are stored in the values array, with the azimuth angle at index 0, pitch at index 1, and roll at index 2.

        Python implementation of the getOrientation method from Android's API, as presented in
        https://can01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fandroid.googlesource.com%2Fplatform%2Fframeworks%2Fbase%2F%2B%2Fmaster%2Fcore%2Fjava%2Fandroid%2Fhardware%2FSensorManager.java&amp;data=05%7C01%7Cmohammad.ghavidel%40intact.net%7C26ca106b04a546ef128708dad9eae652%7Cb880eecaf1fb4c91bff682e84350a6e6%7C0%7C0%7C638061900165893431%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&amp;sdata=pTgNvHa2aELr%2F5lIdnwEA0YCeABiWOci4Mpn7kdPj2U%3D&amp;reserved=0
"""

def getOrientation(R):



        values = np.zeros(3)
        values[0] = np.arctan2((R[0])[1], (R[0])[5])
        values[1] = np.arcsin(-(R[0])[7])
        values[2] = np.arctan2(-(R[0])[6], (R[0])[8])

        return values[0]

"""get_azimuth is getting the acceleramter to calculate Azimuth



1.   Magnetic declination, often referred to simply as 'declination,' represents the angle by which a compass deviates from pointing towards true north. This phenomenon has posed challenges to navigators for centuries, primarily due to its variability based on geographical location and temporal changes.
2.   Magnetic declination is indeed dependent on geographical location, and for the city of Montreal, it is approximately -13.5 degrees.




That why I add -13.5 as adjustment to the formula


"""

def get_azimuth(acc_x, acc_y, acc_z, mag_x, mag_y, mag_z):

    azimuth = []
    R = []
    I = []
    for i in range(0, len(acc_x)):
        accs=(acc_x[i], acc_y[i], acc_z[i])
        mags=(mag_x[i], mag_y[i], mag_z[i])
        R = getRotationMatrix(accs,mags)
        I = getRotationMatrix(accs,mags)
        azimuth.append(np.degrees(getOrientation(R))-13.5)
    return azimuth

"""getRotationMatrix(): This method calculates a rotation matrix based on gravity and geomagnetic sensor values. It takes in four parameters: R (output rotation matrix), I (output inclination matrix), gravity (an array containing gravity sensor values), and geomagnetic (an array containing geomagnetic sensor values).

The method first checks the magnitude of the gravity vector to determine if the device is in free fall or close to the magnetic north pole. If the gravity is below a certain threshold, it returns false to indicate that the rotation matrix cannot be calculated accurately.

If the gravity is within the expected range, the method proceeds to calculate the rotation matrix. It involves various vector operations and normalization to determine the orientation of the device relative to the Earth's magnetic field. The resulting rotation matrix is stored in the R array.

Additionally, if the I parameter is not null, the method computes an inclination matrix based on the geomagnetic vector. The inclination matrix represents the tilt of the device with respect to the Earth's surface. The calculated inclination matrix is stored in the I array.

The method returns true to indicate that the rotation matrix and, optionally, the inclination matrix have been successfully calculated.
"""

def getRotationMatrix(gravity, geomagnetic):


        Ax = gravity[0]
        Ay = gravity[1]
        Az = gravity[2]
        normsqA = (Ax * Ax + Ay * Ay + Az * Az)
        g = 9.81
        freeFallGravitySquared = 0.01 * g * g

        if normsqA < freeFallGravitySquared:
                # gravity less than 10% of normal value
               return False

        Ex = geomagnetic[0]
        Ey = geomagnetic[1]
        Ez = geomagnetic[2]
        Hx = Ey * Az - Ez * Ay
        Hy = Ez * Ax - Ex * Az
        Hz = Ex * Ay - Ey * Ax

        normH = np.sqrt(Hx * Hx + Hy * Hy + Hz * Hz)

        if normH < 0.1:
                # device is close to free fall (or in space?), or close to
                 #magnetic north pole. Typical values are  > 100.
                return False

        invH = 1.0 / normH
        Hx *= invH
        Hy *= invH
        Hz *= invH

        invA = 1.0 / np.sqrt(Ax * Ax + Ay * Ay + Az * Az)
        Ax *= invA
        Ay *= invA
        Az *= invA

        Mx = Ay * Hz - Az * Hy
        My = Az * Hx - Ax * Hz
        Mz = Ax * Hy - Ay * Hx

        R = np.zeros(9)

        R[0] = Hx;     R[1] = Hy;     R[2] = Hz
        R[3] = Mx;     R[4] = My;     R[5] = Mz
        R[6] = Ax;     R[7] = Ay;     R[8] = Az



        invE = 1.0 / np.sqrt(Ex * Ex + Ey * Ey + Ez * Ez)
        c = (Ex * Mx + Ey * My + Ez * Mz) * invE
        s = (Ex * Ax + Ey * Ay + Ez * Az) * invE

        I = np.zeros(9)

        I[0] = 1;     I[1] = 0;     I[2] = 0;
        I[3] = 0;     I[4] = c;     I[5] = s;
        I[6] = 0;     I[7] = -s;    I[8] = c;



        return R, I

def flat_reorientation(X,Y,Z, phi=0 ):

        xm = np.median(X)
        ym = np.median(Y)
        zm = np.median(Z)

        g = np.sqrt(xm**2 + ym**2 + zm**2)

        alpha = np.arcsin(xm/g)
        beta  = np.arcsin(ym/g)

        phi *= -1

        ca = np.cos(alpha)
        sa = np.sin(alpha)
        cb = np.cos(beta)
        sb = np.sin(beta)
        cp = np.cos(phi)
        sp = np.sin(phi)

        l = list(map(
                lambda x,y,z: [
                        y*cb*sp + z*(-cp*sa -ca*sb*sp) + x*(ca*cp -sa*sb*sp),
                        y*cb*cp + x*(-cp*sa*sb -ca*sp) + z*(sa*sp -ca*cp*sb),
                        z*ca*cb + x*sa*cb + y*sb
                ],
                X,Y,Z
        ))

        return np.array(l)

#Reorient the  raw sensors
azimuth = get_azimuth(
        acc['X (m/s^2)'], acc['Y (m/s^2)'], acc['Z (m/s^2)'],
        mag['X (µT)'], mag['Y (µT)'], mag['Z (µT)']
)

# change pyplot style
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import scipy.signal
import math
plt.style.use('bmh')
#the window is chosen based on frequency of sensor 10 Hz and for the sma filter half of this size is recommended

def sma_filter(l, w=5):
        return np.convolve(l, np.ones((w,))/w, mode='valid')

def median_filter(l, w=11):
        return scipy.signal.medfilt(l, w)

def pm_180(l):
        """ Change range from [0,360) to [-180,180] """
        return np.array([ v if v<=180 else v-360 for v in l ])

#smoothing the heading and azmuth with 11 window (based on 10 Hz frequency)

azimuth = median_filter(azimuth)
heading = median_filter(df['heading'])
heading = pm_180(heading)

#yaw would be diffrence between heading and azimuth
yaw = heading - azimuth
yaw = pm_180(yaw)
median_azimuth = np.median(azimuth)
median_heading=np.median(heading)

median_yaw = np.median(yaw)

t = np.linspace(0, len(azimuth)/10.0, len(azimuth))

plt.title('Estimated Yaw')
plt.plot( t, (azimuth), label='azimuth')
plt.plot( t, [median_heading]*len(azimuth), label='Median heading (%.2fº)'%(median_heading) )
plt.plot( t, [median_azimuth]*len(azimuth), label='Median azimuth (%.2fº)'%(median_azimuth) )

plt.plot( t, heading, label='heading')
plt.ylabel('Estimated Yaw (degrees)')
plt.xlabel('Time (s)')
plt.legend(loc='upper left', bbox_to_anchor=(1, 1))
plt.show()

t = np.linspace(0, len(azimuth)/10.0, len(azimuth))

plt.title('Estimated Yaw')
plt.plot( t, yaw, label='Yaw')
plt.plot( t, heading, label='bearing')
plt.plot( t, [median_yaw]*len(azimuth), label='Median of yaw (%.2fº)'%(median_yaw) )
plt.ylabel('Estimated Yaw (degrees)')
plt.xlabel('Time (Seconds)')
plt.legend()
plt.show()

#Reorientation based on phi angel of yaw
r = flat_reorientation(acc['X (m/s^2)'], acc['Y (m/s^2)'], acc['Z (m/s^2)'],np.radians(median_yaw))
dr=pd.DataFrame(r)
dr.columns = ['racc_x','racc_y', 'racc_z']
#Total acceleration after reorientation
dr['racc_total']=np.sqrt(dr['racc_z']**2+ dr['racc_x']**2 + dr['racc_y']**2)

dr=pd.DataFrame(r)
dr.columns = ['racc_x','racc_y', 'racc_z']
#Total acceleration after reorientation
dr['racc_total']=np.sqrt(dr['racc_z']**2+ dr['racc_x']**2 + dr['racc_y']**2)

df['total']=np.sqrt(df['Acc_z']**2+ df['Acc_x']**2 + df['Acc_y']**2)

dr['Acc_x']  = df['Acc_x']
dr['Acc_y']  = df['Acc_y']
dr['Acc_z']  = df['Acc_z']
dr['delta']  = df['delta']
dr['total']= df['total']
dr['speed']  = df['speed']
dr['time'] = df ['time']

#correlation of parameters after reoreintation with yaw as a varible
plt.figure(figsize=(15,10))
correlations = dr.corr()
heatmap= sns.heatmap(round(correlations,2), cmap='BrBG', annot=True, annot_kws={"size": 10}, vmin=-1, vmax=1)
heatmap.set_title('Correlation heatmap', fontdict={'fontsize':18}, pad= 12)
plt.grid(False)

"""## 3-1- Test the methodology"""

sns.boxplot(data=dr[['racc_x','racc_y','racc_z']],dodge=False).set(
    xlabel='Acceleration x',
    ylabel =' $m/s^2$ '
)

#Drawing the plot of
t = np.linspace(0, len(dr)/10.0, len(dr))
plt.title('Acceleration over time')
plt.plot( t, dr['racc_x'], color ='blue')
plt.plot( t, dr['racc_y'], color ='red')
plt.plot( t, dr['racc_z'], color ='green')
plt.legend(['x', 'y','z'])

plt.ylabel("$m/s^2$")
plt.xlabel('Time (Sec)')
plt.show()

"""# 4- Method 2: only using

First find the median of each dimention x, y, z then calculate the g as the total acceleration:

$x_m = median(X)$

$y_m = median(Y)$

$z_m = median(Z)$   

we would use the median and g to normalized the value.

g is would be total acceleration value $m/s^2$

$g = \sqrt{(x_m^2 + y_m^2 + z_m^2)}$

$\alpha = \arccos(\frac{y_m}{z_m})$

$\beta  = \arctan(\frac{x_m}{\sqrt {y_m^2 + Z_m^2}})$
    
$\phi = \arctan(\frac{(-x_m*sin(\beta) +y_m*cos(\beta))}{(x_m*cos(\beta)+y_m*sin(\beta)-z_m*sin(\theta)})
$
"""

df

xm = np.median(acc['X (m/s^2)'])
ym = np.median(acc['Y (m/s^2)'])
zm = np.median(acc['Z (m/s^2)'])
g = np.sqrt(xm**2 + ym**2 + zm**2)

#~Estimating the new accelerameter value only with
def reorientation_new(X,Y,Z):

        xm = np.median(X)
        ym = np.median(Y)
        zm = np.median(Z)

        g = np.sqrt(xm**2 + ym**2 + zm**2)

        alpha = np.arctan(ym/zm)
        beta  = np.arctan(-xm/(np.sqrt(ym+zm)))
        phi = np.arctan((-xm*np.sin(beta) +ym*np.cos(beta))/(xm*np.cos(beta)+ym*np.sin(beta)-zm*np.sin(alpha)))

        ca = np.cos(alpha)
        sa = np.sin(alpha)
        cb = np.cos(beta)
        sb = np.sin(beta)


        l = list(map(
                lambda x,y,z: [
                        y*cb*np.sin(phi) + z*(-np.cos(phi)*sa -ca*sb*np.sin(phi)) + x*(ca*np.cos(phi) -sa*sb*np.sin(phi)),
                        y*cb*np.cos(phi) + x*(-np.cos(phi)*sa*sb -ca*np.sin(phi)) + z*(sa*np.sin(phi) -ca*np.cos(phi)*sb),
                        z*ca*cb + x*sa*cb + y*sb
                ],
                X,Y,Z
        ))

        return np.array(l)

r_new = reorientation_new(acc['X (m/s^2)'], acc['Y (m/s^2)'], acc['Z (m/s^2)'])

dr_new=pd.DataFrame(r_new)
dr_new.columns = ['racc_x','racc_y', 'racc_z']

dr_new['Acc_x']  = df['Acc_x']
dr_new['Acc_y']  = df['Acc_y']
dr_new['Acc_z']  = df['Acc_z']
dr_new['delta']  = df['delta']
dr_new['total']=np.sqrt(df['Acc_z']**2+ df['Acc_x']**2 + df['Acc_y']**2)
dr_new['speed']=df['speed']
dr_new['racc_total']=np.sqrt(dr_new['racc_z']**2+ dr_new['racc_x']**2 + dr_new['racc_y']**2)

#correlation of parameters after reoreintation with yaw as a varible
plt.figure(figsize=(15,10))
correlations = dr_new.corr()
heatmap= sns.heatmap(round(correlations,2), cmap='BrBG', annot=True, annot_kws={"size": 10}, vmin=-1, vmax=1)
heatmap.set_title('Correlation heatmap', fontdict={'fontsize':18}, pad= 12)
plt.grid(False)

sns.boxplot(data=dr_new[['racc_x','racc_y','racc_z']],dodge=False).set(
    xlabel='Acceleration ',
    ylabel =' $m/s^2$ '
)